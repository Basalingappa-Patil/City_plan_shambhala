<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>graph algorithms</title>
    <link rel="stylesheet" href="bootstrap.min.css">
    <link rel="stylesheet" href="styles.css">
	<link href="algorithmcss.css" rel="stylesheet" type="text/css">
	<link href="../ABC/algorithmcss.css" rel="stylesheet" type="text/css">
</head>
<body>
    <!-- Header Section -->
    <header class=" text-white text-center py-3">
        <div class="container">
        </div>
    </header>

    <!-- Main Content Section -->
    <main class="container mt-4">
        <!-- Introduction Section -->
        <section id="intro" class="mb-4">
            <h2 class="text-center">Graph Algorithms</h2>
        
	<p><span>Graph algorithms are indispensable in computer science and 
	practical applications due to their ability to solve complex problems 
	related to network optimization, shortest path finding, and spanning trees. 
	</span></p>
			<p><span>Here’s a brief insight into their importance:</span></p>
	</section>
	<section>
	<h3>Spanning Trees</h3>
	<h4>Kruskal's Algorithm:</h4>
	<ul>
		<li>
		<p><span>Concept<strong>:</strong> Kruskal's algorithm is used to find 
		the Minimum Spanning Tree (MST) of a graph. It sorts all the edges in 
		the graph by their weight and then adds the shortest edge to the MST, 
		ensuring no cycles are formed until all vertices are included.</span></p>
		</li>
		<li>
		<p><span>Importance<strong>:</strong> It is efficient for sparse graphs 
		and helps in network design, such as minimizing the cost of laying out 
		electrical wiring or network cables.</span></p>
		</li>
	</ul>
	<h4>Prim's Algorithm:</h4>
	<ul>
		<li>
		<p><span>Concept<strong>:</strong> Prim's algorithm also finds the MST 
		by starting with a single vertex and repeatedly adding the smallest edge 
		that connects the tree to a vertex not yet in the tree.</span></p>
		</li>
		<li>
		<p><span>Importance: Suitable for dense graphs, it is 
		useful in constructing road networks or optimizing the layout of utility 
		networks.</span></p>
		</li>
	</ul></section><section>
	<h3>Shortest Path</h3>
	<h4>Dijkstra's Algorithm:</h4>
	<ul>
		<li>
		<p><span>Concept:Dijkstra's algorithm finds the 
		shortest path from a source vertex to all other vertices in a weighted 
		graph. It continuously selects the vertex with the minimum distance, 
		updates the distances to its neighbors, and marks it as visited.</span></p>
		</li>
		<li>
		<p><span>Importance:Widely used in GPS navigation 
		systems, network routing protocols, and mapping software to determine 
		the shortest routes.</span></p>
		</li>
	</ul>
	<h4>Bellman-Ford Algorithm:</h4>
	<ul>
		<li>
		<p><span>Concept: The Bellman-Ford algorithm computes 
		the shortest paths from a single source vertex to all other vertices, 
		even if the graph has negative weight edges. It iterates through all 
		edges and updates the path lengths.</span></p>
		</li>
		<li>
		<p><span>Importance: Useful in scenarios where graphs 
		may have negative weights, such as in financial models and varying cost 
		networks.</span></p>
		</li>
	</ul>
	<h4>Floyd-Warshall Algorithm:</h4>
	<ul>
		<li>
		<p><span>Concept: The Floyd-Warshall algorithm finds 
		shortest paths between all pairs of vertices in a weighted graph. It 
		uses dynamic programming to update the shortest paths iteratively.</span></p>
		</li>
		<li>
		<p><span>Importance:Effective for dense graphs, it is 
		used in applications like network routing, urban traffic planning, and 
		social network analysis.</span></p>
		</li>
	</ul>


        </section>
        </main>
         <!-- Footer Section -->
  <footer class="bg-dark text-white text-center py-3">
  </footer>

        </body>
        </html>