<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learn About Sorting Algorithms</title>
    <link rel="stylesheet" href="bootstrap.min.css">
    <link rel="stylesheet" href="styles.css">
	<link href="algorithmcss.css" rel="stylesheet" type="text/css">
	<link href="../ABC/algorithmcss.css" rel="stylesheet" type="text/css">
</head>
<body>
    <!-- Header Section -->
    <header class=" text-white text-center py-3">
        <div class="container">
        </div>
    </header>

    <!-- Main Content Section -->
    <main class="container mt-4">
        <!-- Introduction Section -->
        <section id="intro" class="mb-4">
            <h2 class="text-center">Sorting Algorithms</h2>
            <div class="text-center">
			</div>
			<p class="MsoNormal">Sorting algorithms are designed to arrange data 
			in a particular order (ascending or descending). They are crucial 
			for optimizing search capabilities and improving data handling 
			efficiency.<o:p></o:p></p>
        	<h3 class="MsoNormal">Common Sorting Algorithms:</h3>
			<h4 class="MsoNormal ">Bubble Sort:</h4>
			<p class="MsoNormal ">A simple comparison-based algorithm where 
	each pair of adjacent elements is compared, and the elements are swapped if 
	they are in the wrong order. This process repeats until the list is sorted.<o:p><br>
			<o:p><span>Time Complexity: Best: O(n), Average: O(n²), Worst: O(n²)</span></o:p><h4>Merge Sort</h4>			<p class="MsoNormal">A divide-and-conquer algorithm that splits 
	the list into smaller sublists, sorts them, and then merges them back 
	together. This technique is efficient and works well for large datasets.<br>
			<span>&nbsp;</span>Time Complexity: Best, Average, Worst: 
	O(n log n)</a></p>
			<h4>Quick Sort</h4>			<p class="MsoNormal">&nbsp;An efficient sorting algorithm that uses a 
	pivot element to partition the list into smaller sublists. Elements are 
	rearranged such that those less than the pivot come before it, and those 
	greater come after. This process is recursively applied to the sublists.<o:p><br>Time Complexity: Best: O(n log n), Average: O(n log n), 
	Worst: O(<span>n²</span>)</o:p></a></p>
			<h4>Insertion Sort: </h4>
			<p class="MsoNormal">A straightforward algorithm that builds 
	the sorted list one item at a time. It picks each element from the unsorted 
	list and inserts it into its correct position in the sorted list.<o:p><br>
			<o:p><span>Time Complexity: Best: O(n), Average: O(n²), Worst: O(n²)</span></o:p></o:p></p>
			<h4 >Heap Sort:</h4>
			<p class="MsoNormal">&nbsp;An algorithm that converts the list into a 
	binary heap and then extracts the maximum element repeatedly to build the 
	sorted list. It is efficient and works well for large datasets.<o:p><br>Time Complexity: Best, 
	Average, Worst: O(n log n)</o:p></p>
        </section>
        </main>
         <!-- Footer Section -->
          <footer class="bg-dark text-white text-center py-3">
  </footer>

  
        </body>
        </html>