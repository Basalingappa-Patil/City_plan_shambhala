<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Algorithm design techniques</title>
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="" name="keywords">
  <meta content="" name="description">

  <!-- Bootstrap CSS File -->
  <link href="bootstrap.min.css" rel="stylesheet">

  <!-- Custom CSS File -->
  <link href="styles.css" rel="stylesheet">
  </head>

<body>
  <!-- Header Section -->
  <header id="header" class="bg-primary text-white text-center py-3">
    <div class="container">
      <h1>Algorithm design techniques</h1>
    </div>
  </header>

  <!-- Main Content -->
  <main class="container mt-4">
    <!-- Introduction Section -->
    <section id="intro" class="mb-5">
    <h2 class="text-center">
        Algorithm design techniques are systematic approaches for solving computational problems. These techniques serve as guiding principles for designing efficient and correct algorithms. Below are the most common algorithm design techniques:.</h2>
        <p class="MsoNormal"In the realm of computer science, the efficiency of an algorithm is a paramount concern. This efficiency is primarily measured by two key factors: space efficiency and time efficiency.r 
		lives easier.</p>
		<p class="MsoNormal">&nbsp;</p>
		<p class="MsoNormal"><o:p></o:p></p>
		<o:p>
		<pre></pre>
		

      <p>&nbsp;</p>
    </section>
    <!-- Differentiation Section -->
</section>
  </main>

  
  <!-- Bootstrap JS File -->
  <script src="jquery-3.5.1.slim.min.js"></script>
  <script src="popper.min.js"></script>
  <script src="bootstrap.min.js"></script>
  <ol start="1">
	<h3><strong><span>Divide and conquer</strong></h3>
	  <li>
	  <p class="MsoNormal"><span><strong>Definition: Concept: Divide the problem into smaller subproblems, solve them independently, and combine their solutions.
		  <li>
		  <p class="MsNormal"><span><strong>steps:</strong> 
			.</span></p>
            <p class="MsNormal"><span><strong></strong> Divide the problem into smaller instances.  
                Solve each smaller instance (often recursively).  
                Combine the solutions to form the solution to the original problem.
                .</span></p>
		  </li>
		  <li>
		  <p class="MsNormal"><span><strong>examples::</strong> Merge Sort, 
            Quick Sort, 
            Binary Search, 
            Fast Fourier Transform (FFT)</span></p>
		  </li>
	  </ul>
	  </li>
	  <li>
		<h3><strong><span>Greedy Algorithms</strong></h3>
	  <p><span><strong></strong></span></p>
	  <ul>
		  <li>
		  <p><span><strong>definition:</strong>  Concept: Make the locally optimal choice at each step with the hope of finding a global optimum.</span></p>
          <p class="MsNormal"><span><strong>steps:</strong>
            <p class="MsNormal"><span><strong></strong>Identify a greedy choice property (locally optimal decisions lead to globally optimal results).   
                Solve the problem by repeatedly making the greedy choice.
                .</span></p>
                <p class="MsNormal"><span><strong>examples::</strong> Dijkstra’s Algorithm (Shortest Path), 
                    Kruskal’s and Prim’s Algorithms (Minimum Spanning Tree), 
                    Huffman Coding (Data Compression)
                    
                    .</span></p>
                

		  </li>
		  <li>
		  <p><span><strong>:</strong>  </span></p>
		  </li>
	  </ul>
	  </li>
	  <li>
		<h3><strong><span>Dynamic Programming</strong></h3>
	  <p><span><strong>:</strong></span></p>
	  <ul>
		  <li>
		  <p><span><strong></strong> Concept: Solve problems by breaking them down into overlapping subproblems, storing their solutions to avoid redundant computations.</span></p>
          <p class="MsNormal"><span><strong>steps:</strong> 
			.</span></p>
            <p class="MsNormal"><span><strong></strong>Define the problem in terms of smaller subproblems (state representation).  
                Write a recurrence relation to express the solution.   
                Use a bottom-up or top-down (with memoization) approach.
                 
                .</span></p>
                <p class="MsNormal"><span><strong>examples::</strong> Fibonacci Sequence
                    Knapsack Problem
                    Longest Common Subsequence (LCS)
                    Matrix Chain Multiplication
                    .</span></p>

		  </li>
		  <li>
			<p><span><strong></strong>
		  <p><span><strong>:</strong> 
		   </span></span></p>
		  </li>
	  </ul>
	  </li>
  </ol>
</body>

</html>
